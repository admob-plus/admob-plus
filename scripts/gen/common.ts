import _ from "lodash";
import ts from "typescript";

export const warnMessage =
  "THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.";

export const changes = (u: {
  before: string;
  after: string;
  filename: string;
}) => (u.before === u.after ? {} : { [u.filename]: u.after });

export const indent4 = (n: number) => _.repeat(" ", 4 * n);

export const renderKotlinConstants = <T extends Record<string, string>>(
  m: T,
  indent = 1,
) =>
  _.map(
    m,
    (v, k) =>
      `${indent4(indent)}const val ${_.snakeCase(k).toUpperCase()} = "${v}"`,
  )
    .sort()
    .join("\n");

export function renderKotlinEnums<T extends Record<number, string>>(m: T) {
  return Object.values(m)
    .filter((v) => typeof v !== "number")
    .map((k) => {
      const v = m[k];
      return `${indent4(1)}const val ${_.snakeCase(k).toUpperCase()} = ${v}`;
    })
    .join("\n");
}

export function renderSwiftConstants(m: { [key: string]: string }) {
  return Object.entries(m)
    .map(([k, v]) => `${indent4(1)}static let ${_.camelCase(k)} = "${v}"`)
    .sort()
    .join("\n");
}

export function getUnionTypeValues(
  filePath: string,
  typeName: string,
): string[] {
  const program = ts.createProgram([filePath], {}); // create a program from the file path
  const sourceFile = program.getSourceFile(filePath); // get the source file from the program
  const typeChecker = program.getTypeChecker(); // get the type checker from the program
  let typeNode: ts.TypeNode | undefined; // declare a variable to store the type node
  if (sourceFile) {
    sourceFile.forEachChild((node) => {
      // iterate over the child nodes of the source file
      if (
        ts.isTypeAliasDeclaration(node) &&
        node.name.escapedText === typeName
      ) {
        // check if the node is a type alias declaration with the given name
        typeNode = node.type; // assign the type node to the variable
      }
    });
  }
  if (typeNode) {
    // check if the type node is found
    const type = typeChecker.getTypeFromTypeNode(typeNode); // get the type object from the type node
    if (type.isUnion()) {
      // check if the type is a union type
      return type.types.map((t) => JSON.parse(typeChecker.typeToString(t)));
    }
  }
  return []; // return an empty array if not a union type or not found
}

export function getUnionTypeDict(filePath: string, typeName: string) {
  return _.keyBy(getUnionTypeValues(filePath, typeName));
}
